
// uTstring.cpp
// ユーティリティー関数群で使う文字列型
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

#include  "uTstring.h"


/******************************************************************************/
//		定義
/******************************************************************************/

#define  PSTRING			((_tstring*)this)
#define  ASSERT_TSTRING			if(*PSTRING == TEXT("")){return _tstring("");}
#define  ASSERT_TSTRING_LEN(len)	if(*PSTRING == TEXT("") || PSTRING->size() < len){return _tstring(TEXT(""));}


/******************************************************************************/
//		コンストラクタおよびデストラクタ
/******************************************************************************/
// コンストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring::tstring()
{
	*PSTRING = _tstring();
}


/******************************************************************************/
// コンストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring::tstring(_tstring s)
{
	*PSTRING = s;
}


/******************************************************************************/
// コンストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring::tstring(LPCTSTR p)
{
	if(p == NULL)
	{
		*PSTRING = TEXT("");
	}
	else
	{
		*PSTRING = p;
	}
}


/******************************************************************************/
// デストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring::~tstring()
{
}



/******************************************************************************/
//		抽出
/******************************************************************************/
// 右側抽出
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring tstring::Left(int i) const
{
	ASSERT_TSTRING_LEN(i);
	return PSTRING->substr(0, i);
}


/******************************************************************************/
// 指定範囲抽出
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring tstring::Mid(int intPos, int intCount) const
{
	ASSERT_TSTRING_LEN(intPos + intCount);
	return PSTRING->substr(intPos, intCount);
}


/******************************************************************************/
// 左側抽出
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring tstring::Right(int i) const
{
	ASSERT_TSTRING_LEN(i);

	UINT uiSize = ((_tstring*)this)->size();
	return PSTRING->substr(uiSize - i, i);
}


/******************************************************************************/
//		比較
/******************************************************************************/
// 文字列が等しいか
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL tstring::IsEqual(const tstring& str) const
{
	if(*PSTRING == TEXT(""))
	{
		return str == TEXT("");
	}
	else if(str == TEXT(""))
	{
		return FALSE;
	}

	return _tcscmp(PSTRING->c_str(), str.c_str()) == 0;
}


/******************************************************************************/
// 文字列が等しいか（大文字小文字を区別しない）
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL tstring::IsEqualNoCase(const tstring& str) const
{
	if(*PSTRING == TEXT(""))
	{
		return str == TEXT("");
	}
	else if(str == TEXT(""))
	{
		return FALSE;
	}

	return _tcsicmp(PSTRING->c_str(), str.c_str()) == 0;
}


/******************************************************************************/
//		変換
/******************************************************************************/
// 文字を変換
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int tstring::Replace(TCHAR chOld, TCHAR chNew)
{
	if(*PSTRING == TEXT("")) return 0;

	int intPos = 0;
	int intCount = 0;
	while(1)
	{
		intPos = PSTRING->find(chOld, intPos);
		if(intPos == tstring::npos)
		{
			break;
		}

		PSTRING->replace(intPos, 1, 1, chNew);
		intPos++;
		intCount++;
	}

	return intCount;
}


/******************************************************************************/
// 文字を変換
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int tstring::Replace(LPCTSTR pszOld, LPCTSTR pszNew)
{
	if(*PSTRING == TEXT("")) return 0;
	if(tstring(pszOld) == TEXT("")) return 0;

	int intPos = 0;
	int intCount = 0;
	while(1)
	{
		intPos = PSTRING->find(pszOld, intPos);
		if(intPos == tstring::npos) break;

		PSTRING->replace(intPos, lstrlen(pszOld), pszNew);
		intPos += lstrlen(pszNew);
		intCount++;
	}

	return intCount;
}


/******************************************************************************/
// フォーマット
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

void tstring::Format(LPCTSTR pszFormat, ...)
{
	va_list	argp;
	va_start(argp, pszFormat);

	DWORD dwByte = 256;
	LPTSTR pszBuf;
	while(1)
	{
		pszBuf = new TCHAR[dwByte];
		if(_vsntprintf(pszBuf, dwByte, pszFormat, argp) != -1)
		{
			break;
		}

		dwByte *= 2;
	}

	va_end(argp);
	*PSTRING = pszBuf;
	delete[] pszBuf;
}


/******************************************************************************/
// トリミング左
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

void tstring::TrimLeft(TCHAR c)
{
	if(*PSTRING == TEXT("")) return;

	for(int i = 0; i < PSTRING->size(); i++)
	{
		if(PSTRING->at(i) != c)
		{
			*PSTRING = PSTRING->substr(i);
			return;
		}
	}

	*PSTRING = TEXT("");
}


/******************************************************************************/
// トリム左
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

void tstring::TrimLeft(LPCTSTR pszTarget)
{
	if(*PSTRING == TEXT("")) return;

	for(int i = 0; i < PSTRING->size(); i++)
	{
		if(!IsTrimmable(PSTRING->at(i), pszTarget))
		{
			*PSTRING = PSTRING->substr(i);
			return;
		}
	}

	*PSTRING = TEXT("");
}


/******************************************************************************/
// トリミング右
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

void tstring::TrimRight(TCHAR c)
{
	if(*PSTRING == TEXT("")) return;

	for(int i = PSTRING->size() - 1; i >= 0; i--)
	{
		if(PSTRING->at(i) != c)
		{
			*PSTRING = PSTRING->substr(0, i + 1);
			return;
		}
	}

	*PSTRING = TEXT("");
}


/******************************************************************************/
// トリム右
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

void tstring::TrimRight(LPCTSTR pszTarget)
{
	if(*PSTRING == TEXT("")) return;

	for(int i = PSTRING->size() - 1; i >= 0; i--)
	{
		if(!IsTrimmable(PSTRING->at(i), pszTarget))
		{
			*PSTRING = PSTRING->substr(0, i + 1);
			return;
		}
	}

	*PSTRING = TEXT("");
}


/******************************************************************************/
// 整数に変換
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int tstring::toInt() const
{
	if(*PSTRING == TEXT(""))
	{
		return 0;
	}

	return _ttoi(PSTRING->c_str());
}


/******************************************************************************/
// トリム可能か
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL tstring::IsTrimmable(TCHAR c, LPCTSTR pszTarget)
{
	int intLen = lstrlen(pszTarget);
	for(int i = 0; i < intLen; i++)
	{
		if(c == pszTarget[i])
		{
			return TRUE;
		}
	}

	return FALSE;
}


/******************************************************************************/
//		グローバル関数
/******************************************************************************/
// UNICODE→SJIS
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

const string Unicode2Sjis(const wstring& str)
{
	int intSize = WideCharToMultiByte(CP_ACP, 0, str.c_str(), -1, NULL, 0, NULL, NULL);
	char* pszBuf = new char[intSize];
	WideCharToMultiByte(CP_ACP, 0, str.c_str(), -1, pszBuf, intSize, NULL, NULL);

	string strRet = pszBuf;
	delete[] pszBuf;

	return strRet;
}


/******************************************************************************/
// SJIS→UNICODE
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

const wstring Sjis2Unicode(const string& str)
{
	int intSize = MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, NULL, 0);
	WCHAR* pszBuf = new WCHAR[intSize];
	MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, pszBuf, intSize);

	wstring strRet = pszBuf;
	delete[] pszBuf;

	return strRet;
}


/******************************************************************************/
// 文字列が等しいか
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL IsStrEqual(const tstring& str1, const tstring& str2)
{
	return str1.IsEqual(str2);
}


/******************************************************************************/
// 文字列が等しいか（大文字小文字を区別しない）
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL IsStrEqualNoCase(const tstring& str1, const tstring& str2)
{
	return str1.IsEqualNoCase(str2);
}


/******************************************************************************/
// 文字列を分割
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

vector<tstring> SplitStr(const tstring& str, const tstring& strDelimiter)
{
	vector<tstring> vecRet;
	tstring strTmp = str;
	
	// 空文字列の場合は、0 個の要素を持つ配列を返す
	if(str == TEXT(""))
	{
		return vecRet;
	}

	while(TRUE)
	{
		UINT uiNext = strTmp.find(strDelimiter);

		if(uiNext == tstring::npos)
		{
			vecRet.push_back(strTmp);
			break;
		}

		vecRet.push_back(strTmp.substr(0, uiNext));

		if(strTmp.size() == uiNext + strDelimiter.size())
		{
			vecRet.push_back(TEXT(""));
			break;
		}
		strTmp = strTmp.substr(uiNext + strDelimiter.size());
	}

	return vecRet;
}


/******************************************************************************/
// 数字から文字列
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring Int2Str(int i)
{
	TCHAR pszBuf[65];
	wsprintf(pszBuf, TEXT("%d"), i);
	return tstring(pszBuf);
}


/******************************************************************************/
// 数字から文字列
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring Uint2Str(unsigned int i)
{
	TCHAR pszBuf[65];
	wsprintf(pszBuf, TEXT("%u"), i);
	return tstring(pszBuf);
}


/******************************************************************************/
// 文字列から数字
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int Str2Int(const tstring& s)
{
	return s.toInt();
}


/******************************************************************************/
// HEX Encode
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring Str2Hex(const tstring& strData)
{
	tstring strRet = TEXT("");
	tstring s;

	for(int i = 0; i < strData.size(); i++)
	{
		s.Format(TEXT("%02X"), (unsigned char)strData[i]);
		strRet += s;
	}

	return strRet;
}


/******************************************************************************/
// HEX decode
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int Hex2Char(TCHAR c)
{
	if(c >= '0' && c <= '9')
	{
		return c - '0';
	}
	else if(c >= 'a' && c <= 'f')
	{
		return c - 'a' + 10;
	}
	else if(c >= 'A' && c <= 'F')
	{
		return c - 'A' + 10;
	}

	return 0;
}

/******************************************************************************/
// HEX decode
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring Hex2Str(const tstring& strData)
{
	unsigned char c;
	tstring strRet = TEXT("");
	for(int i = 0; i < strData.size() / 2; i++)
	{
		c = Hex2Char(strData[i * 2]) * 16 + Hex2Char(strData[i * 2 + 1]);
		strRet += c;
	}

	return strRet;
}


/******************************************************************************/
// GetLastErr の数値を文字列に変換
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring Err2Str(DWORD dwErr)
{
	LPVOID lpMsgBuf;
	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, dwErr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // デフォルト言語
		(LPTSTR)&lpMsgBuf, 0, NULL);

	tstring strRet = (LPTSTR)lpMsgBuf;
	LocalFree(lpMsgBuf);
	return strRet;
}


/******************************************************************************/
// 変換
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring ConvertUsingValues(const tstring& strGiven, const map<TCHAR, tstring>& mapValue, TCHAR c)
{
	tstring strRet;

	BOOL blnEscape = FALSE;
	for(UINT i = 0; i < strGiven.size(); i++)
	{
		// エスケープ文字の処理
		if(blnEscape)
		{
			blnEscape = FALSE;

			if(strGiven[i] == TEXT('%'))
			{
				strRet += TEXT('%');
				continue;
			}

			map<TCHAR, tstring>::const_iterator p = mapValue.find(strGiven[i]);
			if(p != mapValue.end())
			{
				strRet += p->second;
			}
			continue;
		}

		if(strGiven[i] == TEXT('%'))
		{
			blnEscape = TRUE;
		}
		else
		{
			strRet += strGiven[i];
		}
	}

	return strRet;
}