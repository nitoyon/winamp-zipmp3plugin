
// uTstring.cpp
// ユーティリティー関数群で使う文字列型
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

#include  "uTstring.h"


/******************************************************************************/
//		定義
/******************************************************************************/

#define  PSTRING			((_tstring*)this)
#define  ASSERT_TSTRING			if(*PSTRING == TEXT("")){return _tstring("");}
#define  ASSERT_TSTRING_LEN(len)	if(*PSTRING == TEXT("") || PSTRING->size() < len){return _tstring("");}


/******************************************************************************/
//		コンストラクタおよびデストラクタ
/******************************************************************************/
// コンストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring::tstring()
{
	*PSTRING = _tstring();
}


/******************************************************************************/
// コンストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring::tstring(_tstring s)
{
	*PSTRING = s;
}


/******************************************************************************/
// コンストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring::tstring(LPCTSTR p)
{
	*PSTRING = p;
}


/******************************************************************************/
// デストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring::~tstring()
{
}



/******************************************************************************/
//		抽出
/******************************************************************************/
// 右側抽出
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring tstring::Left(int i) const
{
	ASSERT_TSTRING_LEN(i);
	return PSTRING->substr(0, i);
}


/******************************************************************************/
// 指定範囲抽出
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring tstring::Mid(int intPos, int intCount) const
{
	ASSERT_TSTRING_LEN(intPos + intCount);
	return PSTRING->substr(intPos, intCount);
}


/******************************************************************************/
// 左側抽出
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring tstring::Right(int i) const
{
	ASSERT_TSTRING_LEN(i);

	UINT uiSize = ((_tstring*)this)->size();
	return PSTRING->substr(uiSize - i, i);
}


/******************************************************************************/
//		比較
/******************************************************************************/
// 文字列が等しいか
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL tstring::IsEqual(const tstring& str) const
{
	if(*PSTRING == TEXT(""))
	{
		return str == TEXT("");
	}
	else if(str == TEXT(""))
	{
		return FALSE;
	}

	return _tcscmp(PSTRING->c_str(), str.c_str()) == 0;
}


/******************************************************************************/
// 文字列が等しいか（大文字小文字を区別しない）
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL tstring::IsEqualNoCase(const tstring& str) const
{
	if(*PSTRING == TEXT(""))
	{
		return str == TEXT("");
	}
	else if(str == TEXT(""))
	{
		return FALSE;
	}

	return _tcsicmp(PSTRING->c_str(), str.c_str()) == 0;
}


/******************************************************************************/
//		変換
/******************************************************************************/
// 文字を変換
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int tstring::Replace(TCHAR chOld, TCHAR chNew)
{
	if(*PSTRING == TEXT("")) return 0;

	int intPos = 0;
	int intCount = 0;
	while(1)
	{
		intPos = PSTRING->find(chOld, intPos);
		if(intPos == tstring::npos)
		{
			break;
		}

		PSTRING->replace(intPos, 1, 1, chNew);
		intPos++;
		intCount++;
	}

	return intCount;
}


/******************************************************************************/
// 文字を変換
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int tstring::Replace(LPCTSTR pszOld, LPCTSTR pszNew)
{
	if(*PSTRING == TEXT("")) return 0;

	int intPos = 0;
	int intCount = 0;
	while(1)
	{
		intPos = PSTRING->find(pszOld, intPos);
		if(intPos == tstring::npos) break;

		PSTRING->replace(intPos, lstrlen(pszOld), pszNew);
		intCount++;
	}

	return intCount;
}


/******************************************************************************/
// フォーマット
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

void tstring::Format(LPCTSTR pszFormat, ...)
{
	va_list	argp;
	va_start(argp, pszFormat);

	DWORD dwByte = 256;
	LPTSTR pszBuf;
	while(1)
	{
		pszBuf = new TCHAR[dwByte];
		if(_vsntprintf(pszBuf, dwByte, pszFormat, argp) != -1)
		{
			break;
		}

		dwByte *= 2;
	}

	va_end(argp);
	*PSTRING = pszBuf;
	delete[] pszBuf;
}


/******************************************************************************/
// 整数に変換
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int tstring::toInt() const
{
	if(*PSTRING == TEXT(""))
	{
		return 0;
	}

	return _ttoi(PSTRING->c_str());
}


/******************************************************************************/
//		グローバル関数
/******************************************************************************/
// UNICODE→SJIS
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

const string Unicode2Sjis(const wstring& str)
{
	int intSize = WideCharToMultiByte(CP_ACP, 0, str.c_str(), -1, NULL, 0, NULL, NULL);
	char* pszBuf = new char[intSize];
	WideCharToMultiByte(CP_ACP, 0, str.c_str(), -1, pszBuf, intSize, NULL, NULL);

	string strRet = pszBuf;
	delete[] pszBuf;

	return strRet;
}


/******************************************************************************/
// SJIS→UNICODE
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

const wstring Sjis2Unicode(const string& str)
{
	int intSize = MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, NULL, 0);
	WCHAR* pszBuf = new WCHAR[intSize];
	MultiByteToWideChar(CP_ACP, 0, str.c_str(), -1, pszBuf, intSize);

	wstring strRet = pszBuf;
	delete[] pszBuf;

	return strRet;
}


/******************************************************************************/
// 文字列が等しいか
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL IsStrEqual(const tstring& str1, const tstring& str2)
{
	return str1.IsEqual(str2);
}


/******************************************************************************/
// 文字列が等しいか（大文字小文字を区別しない）
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL IsStrEqualNoCase(const tstring& str1, const tstring& str2)
{
	return str1.IsEqualNoCase(str2);
}


/******************************************************************************/
// 文字列を分割
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

vector<tstring> SplitStr(const tstring& str, const tstring& strDelimiter)
{
	vector<tstring> vecRet;
	tstring strTmp = str;

	while(TRUE)
	{
		UINT uiNext = strTmp.find(strDelimiter);

		if(uiNext == tstring::npos)
		{
			vecRet.push_back(strTmp);
			break;
		}

		vecRet.push_back(strTmp.substr(0, uiNext));
		strTmp = strTmp.substr(uiNext + strDelimiter.size());
	}

	return vecRet;
}


/******************************************************************************/
// 数字から文字列
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

tstring Int2Str(int i)
{
	TCHAR pszBuf[65];
	wsprintf(pszBuf, TEXT("%d"), i);
	return tstring(pszBuf);
}


/******************************************************************************/
// 文字列から数字
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int Str2Int(const tstring& s)
{
	return s.toInt();
}

