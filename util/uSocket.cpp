
// uSocket.cpp
// ソケットを扱うユーティリティー関数群
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

#include "uSocket.h"
#include "uStl.h"
#pragma comment(lib, "winmm.lib")


/******************************************************************************/
//		プロトタイプ宣言
/******************************************************************************/

void CALLBACK uTimerProc_(UINT uiId, UINT uiMsg, DWORD dwUser, DWORD, DWORD);


/******************************************************************************/
//		コンストラクタおよびデストラクタ
/******************************************************************************/
// コンストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

uSocket::uSocket()
: soc(INVALID_SOCKET)
{
}


/******************************************************************************/
// コンストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

uSocket::uSocket(SOCKET s)
{
	soc = s;
}


/******************************************************************************/
// デストラクタ
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

uSocket::~uSocket()
{
	if(soc != INVALID_SOCKET)
	{
		closesocket(soc);
	}
}


/******************************************************************************/
//		取得
/******************************************************************************/
// 取得
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

SOCKET uSocket::GetInstance() const
{
	return soc;
}


/******************************************************************************/
//		作成廃棄
/******************************************************************************/
// 作成
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::Create(int af, int type, int protocol)
{
	if(soc != INVALID_SOCKET)
	{
		Close();
	}

	soc = socket(af, type, protocol);
	return (soc != INVALID_SOCKET);
}


/******************************************************************************/
// 閉じる
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::Close()
{
	return closesocket(soc) == 0;
}


/******************************************************************************/
// きれいにソケットを閉じる
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::CleanClose(UINT uiTimeout)
{
	Shutdown(1);
	BYTE* pByte = ReceiveTillChar(NULL, uiTimeout);
	if(pByte)
	{
		delete[] pByte;
	}
	return Close();
}


/******************************************************************************/
//		接続
/******************************************************************************/
// バインド（待ち受け用ソケットの割り当て）
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::Bind(LPCTSTR pszAddress, UINT uiPort)
{
	// SOCKADDR 構造体生成
	SOCKADDR_IN name;
	memset(&name, 0, sizeof(name));
	name.sin_family = AF_INET;
	name.sin_port = htons(uiPort);

	if(pszAddress == NULL)
	{
		name.sin_addr.s_addr = htonl(INADDR_ANY);
	}
	else
	{
		DWORD lResult = inet_addr(pszAddress);
		if(lResult == INADDR_NONE)
		{
			WSASetLastError(WSAEINVAL);
			return FALSE;
		}
		name.sin_addr.s_addr = lResult;
	}

	return Bind((SOCKADDR*)&name, sizeof(SOCKADDR_IN));
}


/******************************************************************************/
// バインド（待ち受け用ソケットの割り当て）
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::Bind(const SOCKADDR* lpSockAddr, int intSockAddrLen)
{
	return bind(soc, lpSockAddr, intSockAddrLen) == 0;
}


/******************************************************************************/
// リッスン（待ち受けソケットを待機状態にする）
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::Listen(int intBackLog)
{
	return listen(soc, intBackLog) == 0;
}


/******************************************************************************/
// 接続しにいく
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::Connect(LPCTSTR pszAddress, UINT uiPort)
{
	// SOCKADDR 構造体生成
	SOCKADDR_IN name;
	memset(&name, 0, sizeof(name));
	name.sin_family = AF_INET;
	name.sin_port = htons(uiPort);

	if(pszAddress == NULL)
	{
		name.sin_addr.s_addr = htonl(INADDR_ANY);
	}
	else
	{
		DWORD lResult = inet_addr(pszAddress);
		if(lResult == INADDR_NONE)
		{
			WSASetLastError(WSAEINVAL);
			return FALSE;
		}
		name.sin_addr.s_addr = lResult;
	}

	return Connect((SOCKADDR*)&name, sizeof(SOCKADDR_IN));
}


/******************************************************************************/
// 接続しにいく
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::Connect(const SOCKADDR* lpSockAddr, int intSockAddrLen)
{
	return connect(soc, lpSockAddr, intSockAddrLen) == 0;
}


/******************************************************************************/
// シャットダウン
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::Shutdown(int intHow)
{
	return shutdown(soc, intHow) == 0;
}



/******************************************************************************/
//		送受信
/******************************************************************************/
// 送信
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int uSocket::Send(const void* lpBuf, int intBufLen, int intFlag)
{
	return send(soc, (const char*)lpBuf, intBufLen, intFlag);
}


/******************************************************************************/
// 受信
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

int uSocket::Receive(void* lpBuf, int intBufLen, int intFlags)
{
	return recv(soc, (char*)lpBuf, intBufLen, intFlags);
}


/******************************************************************************/
// 受け入れる
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

SOCKET uSocket::Accept(SOCKADDR* lpSockAddr, int* lpSockAddrLen)
{
	return accept(soc, lpSockAddr, lpSockAddrLen);
}


/******************************************************************************/
//		設定変更
/******************************************************************************/
// ソケットの設定変更
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::IOCtl(LONG lCommand, DWORD* lpArgument)
{
	return ioctlsocket(soc, lCommand, lpArgument) == 0;
}


/******************************************************************************/
// ソケットを block にするか non-block にするかを設定
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BOOL uSocket::SetBlocking(BOOL blnBlock)
{
	u_long uBlock = (blnBlock ? 0 : 1);
	return IOCtl(FIONBIO, &uBlock);
}


/******************************************************************************/
//		上位関数
/******************************************************************************/
// 特定の文字が現れるまで受信
//============================================================================//
// 概要：なし。
// 補足：Blocking では Timeout が無視されることがある。pszEnd が NULL の場合、最後まで受信する。
//============================================================================//

BYTE* uSocket::ReceiveTillChar(LPSTR pszEnd, UINT uiTimeout, BOOL blnAddNull)
{
	string s;
	DWORD dwStartTime = GetTickCount();
	char pszBuf[256];

	while(1)
	{
		// 受信したとき
		int intSize = Receive(pszBuf, 255, MSG_PEEK);
		if(intSize > 0)
		{
			// 終了文字を受信しなかった場合
			pszBuf[intSize] = '\0';
			string strTmp = pszBuf;

			if(pszEnd == NULL || strTmp.find(pszEnd) == string::npos)
			{
				Receive(pszBuf, intSize, 0);
				s += pszBuf;
			}
			// 終了文字を受信した場合
			else
			{
				int intEnd = strTmp.find(pszEnd);
				intSize = Receive(pszBuf, intEnd + strlen(pszEnd), 0);
				pszBuf[intSize] = '\0';
				s += pszBuf;
				break;
			}
		}
		// 受信できなかったとき
		else
		{
			int intErr = WSAGetLastError();
			if(intErr == WSAEWOULDBLOCK)
			{
				DWORD dwCur = GetTickCount();
				if(dwStartTime < dwCur)
				{
					if(dwCur - dwStartTime > uiTimeout)
					{
						break;
					}
				}
				else
				{
					if(dwStartTime - dwCur < 0xFFFFFFFFFFFFFFFF - uiTimeout)
					{
						break;
					}
				}
				continue;
			}
			else
			{
				break;
			}
		}
	}

	if(s.size() == 0)
	{
		return NULL;
	}

	// コピー
	BYTE* pbyte = new BYTE[s.size() + (blnAddNull ? 1 : 0)];
	memcpy(pbyte, s.c_str(), s.size());
	if(blnAddNull) pbyte[s.size()] = '\0';

	return pbyte;
}


/******************************************************************************/
// 一行読み取り
//============================================================================//
// 概要：なし。
// 補足：なし。
//============================================================================//

BYTE* uSocket::ReceiveLine(UINT uiTimeout, BOOL blnAddNull)
{
	return ReceiveTillChar("\n", uiTimeout, blnAddNull);
}
